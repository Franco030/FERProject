# CFER - Fer Language Interpreter

CFER is a bytecode virtual machine and interpreter for the Fer programming language, implemented in C. This project focuses on performance and portability, utilizing a custom stack-based VM, a single-pass compiler, and manual memory management.

## Project Overview

The interpreter works by compiling source code directly into a dense bytecode representation, which is then executed by a virtual machine. This architecture separates the compilation phase (parsing and error checking) from the runtime execution phase.

## Features

* **Data Types**: Support for floating-point numbers, booleans, strings, and nil.
* **Arithmetic & Logic**: Complete set of binary and unary operators.
* **Variables**: Global and local variable scope declarations.
* **Control Flow**: Support for `if/else` branching, `while` loops, and `for` loops.
* **Functions**: First-class functions, allowing function declarations, calls, and return values.
* **Native Functions**: Support for C-native functions (e.g., `clock()`) bound to the VM.
* **String Interning**: All strings are interned using a hash table for efficient equality checks.
* **Debug Tools**: Built-in disassembler to view generated bytecode chunks.

## Architecture

The project is structured into several modular components:

* **Virtual Machine (vm.c/h)**: The core module that executes the bytecode. It maintains the value stack, call frames, and global state.
* **Compiler (compiler.c/h)**: A single-pass Pratt parser that translates source tokens directly into bytecode chunks.
* **Scanner (scanner.c/h)**: Performs lexical analysis, converting source code strings into a stream of tokens.
* **Chunk (chunk.c/h)**: Represents a sequence of bytecode instructions and constants.
* **Memory (memory.c/h)**: Handles dynamic memory allocation, array resizing, and object freeing.
* **Table (table.c/h)**: A hash table implementation used for symbol tables and string interning.
* **Values & Objects (value.c/h, object.c/h)**: Defines the runtime representation of data (tagged unions for small values, heap allocation for larger objects like strings and functions).

## Prerequisites

* **C Compiler**: GCC, Clang, or MSVC supporting C17 standard.
* **CMake**: Version 3.17 or higher.

## Build Instructions

To build the interpreter, navigate to the project root and run the following commands:

```sh
mkdir build
cd build
cmake ..
make

```

This will generate the `cfer` executable.

## Usage

### Interactive REPL

Running the executable without arguments starts the Read-Eval-Print Loop (REPL). You can type Fer code line-by-line and see the immediate output.

```sh
./cfer
> print "Hello, World!";
Hello, World!
> 1 + 2 * 3
7

```

### File Execution

To execute a script file, pass the path to the file as an argument:

```sh
./cfer path/to/script.fer

```

## Language Syntax Examples

**Variables and Printing:**

```fer
var breakfast = "beignets";
var beverage = "cafe au lait";
print breakfast; 
print beverage;

```

**Control Flow:**

```fer
var condition = true;
if (condition) {
    print "yes";
} else {
    print "no";
}

var i = 0;
while (i < 10) {
    print i;
    i = i + 1;
}

```

**Functions:**

```fer
fun add(a, b) {
    return a + b;
}

print add(5, 10);

```

## Internal Development

### Debugging

The project includes a `debug.c` module. By defining `DEBUG_PRINT_CODE` or `DEBUG_TRACE_EXECUTION` in `common.h` (or enabling them if commented out), the VM will print the disassembled bytecode and the state of the stack during execution.

### Memory Management

Memory is managed manually via `reallocate` in `memory.c`. Objects (strings, functions) are allocated on the heap. String interning is handled via `table.c` to ensure unique instances of string literals.

## Roadmap

Future improvements planned for the Fer language:

* Implementation of `switch` statements.
* Conditional expressions (ternary operator).
* Enhanced loop control (`break` and `continue`).
* Arity checking improvements for native functions.
* Expansion of local variable limits.